name: Auto-Merge Pending Publish PRs (Single Deploy - Optimized)

on:
  schedule:
    # Monday, Wednesday, Friday at 10:35 AM EST (14:35 UTC)
    - cron: "35 14 * * 1,3,5"
  workflow_dispatch:

jobs:
  batch_merge_and_sync:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
      actions: write
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Configure Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
      
      - name: Gather PRs with label "decap-cms/pending_publish"
        id: gather
        run: |
          prs=$(gh pr list \
            --state open \
            --label "decap-cms/pending_publish" \
            --json number,headRefName \
            --jq '.[] | "\(.number):\(.headRefName)"' | paste -sd "," -)
          
          pr_count=$(gh pr list \
            --state open \
            --label "decap-cms/pending_publish" \
            --json number \
            --jq '. | length')
          
          echo "prs=$prs" >> $GITHUB_OUTPUT
          echo "pr_count=$pr_count" >> $GITHUB_OUTPUT
          
          if [ "$pr_count" -gt 0 ]; then
            echo "Found $pr_count pending PRs to merge"
          else
            echo "No pending PRs found"
          fi
      
      - name: Batch merge all PRs (Don't push yet)
        if: steps.gather.outputs.prs != ''
        id: merge
        run: |
          # Parse PR numbers and branch names
          IFS=',' read -ra pr_array <<< "${{ steps.gather.outputs.prs }}"
          
          pr_numbers=""
          merged_prs=""
          
          # Checkout main and pull latest
          git checkout main
          git pull origin main
          
          # Merge each PR branch locally (but DON'T push yet)
          for pr_info in "${pr_array[@]}"; do
            pr_number=$(echo "$pr_info" | cut -d':' -f1)
            branch_name=$(echo "$pr_info" | cut -d':' -f2)
            
            echo "Merging PR #$pr_number (branch: $branch_name)"
            
            # Skip workflow-changing PRs for safety
            changed_files=$(gh pr view "$pr_number" --json files --jq '.files[].path')
            if echo "$changed_files" | grep -q '^.github/workflows/'; then
              echo "Skipping PR #$pr_number - modifies workflows"
              continue
            fi
            
            # Fetch and merge the PR branch
            git fetch origin "$branch_name"
            if git merge "origin/$branch_name" --no-edit --no-ff; then
              echo "Merged PR #$pr_number"
              pr_numbers="$pr_numbers #$pr_number"
              merged_prs="$merged_prs $pr_number"
            else
              echo "Failed to merge PR #$pr_number"
            fi
          done
          
          echo "merged_prs=$merged_prs" >> $GITHUB_OUTPUT
          
          # Check if we have changes (but don't push yet)
          if git diff --quiet origin/main; then
            echo "No changes to merge"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "Merged PRs:$pr_numbers (not pushed yet)"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Sync service listings to services.json
        if: steps.merge.outputs.has_changes == 'true'
        run: |
          echo "Syncing approved service listings to services.json..."
          echo "Current directory: $(pwd)"
          echo "Contents of data directory:"
          ls -la data/ || echo "data/ directory not found"
          echo "Contents of data/services directory:"
          ls -la data/services/ || echo "data/services/ directory not found"
          
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          console.log('=== SYNC PROCESS STARTING ===');
          console.log('Current working directory:', process.cwd());
          
          // Read existing services.json
          const servicesPath = 'data/services.json';
          let services = [];
          
          if (fs.existsSync(servicesPath)) {
            services = JSON.parse(fs.readFileSync(servicesPath, 'utf8'));
            console.log(`Loaded ${services.length} existing services from services.json`);
          } else {
            console.log('services.json does not exist, will create new one');
          }
          
          // Track the highest existing ID number
          let maxId = 0;
          services.forEach(service => {
            const match = service.id.match(/fb(\d+)/);
            if (match) {
              maxId = Math.max(maxId, parseInt(match[1]));
            }
          });
          
          console.log(`Highest existing ID: fb${maxId}`);
          
          // Get all approved service listing files from data/services
          const servicesDir = 'data/services';
          
          if (!fs.existsSync(servicesDir)) {
            console.log(`ERROR: Directory ${servicesDir} does not exist!`);
            process.exit(1);
          }
          
          const allFiles = fs.readdirSync(servicesDir);
          console.log(`All files in ${servicesDir}:`, allFiles);
          
          const files = allFiles.filter(file => file.endsWith('.json'));
          console.log(`Filtered JSON files:`, files);
          
          console.log(`Found ${files.length} service listing files`);
          
          if (files.length === 0) {
            console.log('WARNING: No JSON files found in data/services/');
            process.exit(0);
          }
          
          files.forEach(file => {
            const filePath = path.join(servicesDir, file);
            console.log(`Processing file: ${filePath}`);
            
            const listing = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            console.log(`Loaded listing:`, listing.name);
            
            // Generate unique ID
            let id = file.replace('.json', '').toLowerCase().replace(/[^a-z0-9]/g, '-');
            
            // Check if this listing already exists (by name or ID)
            const existingIndex = services.findIndex(s => 
              s.name === listing.name || s.id === id
            );
            
            // If not using fb{N} format, assign next available fb ID
            if (!id.match(/^fb\d+$/)) {
              if (existingIndex === -1) {
                maxId++;
                id = `fb${maxId}`;
              } else {
                id = services[existingIndex].id;
              }
            }
            
            // Create service object matching services.json format
            const serviceObj = {
              id: id,
              name: listing.name,
              type: listing.type || 'food_bank',
              address: listing.address,
              location: {
                lat: parseFloat(listing.location?.lat || listing.lat || 0),
                lng: parseFloat(listing.location?.lng || listing.lng || 0)
              },
              days: listing.days || [],
              hours: listing.hours || '',
              phone: listing.phone || '',
              description: listing.description || '',
              tags: listing.tags || []
            };
            
            // Add optional fields if they exist
            if (listing.email) serviceObj.email = listing.email;
            if (listing.website) serviceObj.website = listing.website;
            
            if (existingIndex >= 0) {
              // Update existing service
              console.log(`Updating existing service: ${listing.name} (${id})`);
              services[existingIndex] = serviceObj;
            } else {
              // Add new service
              console.log(`Adding new service: ${listing.name} (${id})`);
              services.push(serviceObj);
            }
          });
          
          // Write updated services.json
          fs.writeFileSync(servicesPath, JSON.stringify(services, null, 2));
          
          console.log(`=== SYNC COMPLETE ===`);
          console.log(`Updated services.json with ${services.length} total services`);
          console.log('Service IDs:', services.map(s => s.id).join(', '));
          EOF
      
      - name: Push all changes in ONE commit (Single Deploy)
        if: steps.merge.outputs.has_changes == 'true'
        run: |
          # Add services.json if it changed
          git add data/services.json
          
          # Check if there are any changes to commit
          if git diff --staged --quiet; then
            echo "No changes to services.json"
            # Just push the merged PRs
            git push origin main
            echo "Pushed merged PRs only"
          else
            # Commit services.json update
            git commit -m "Auto-update: Sync approved service listings to services.json"
            # Push everything (merged PRs + services.json) in ONE push
            git push origin main
            echo "Pushed merged PRs + services.json in ONE deployment"
          fi
      
      - name: Close merged PRs
        if: steps.merge.outputs.merged_prs != ''
        run: |
          merged_prs="${{ steps.merge.outputs.merged_prs }}"
          
          for pr_number in $merged_prs; do
            echo "Closing PR #$pr_number"
            gh pr close "$pr_number" --comment "Auto-merged in batch deploy" || true
          done
      
      - name: Summary
        if: always()
        run: |
          echo "----------------------------------------"
          echo "WORKFLOW SUMMARY"
          echo "----------------------------------------"
          
          if [ "${{ steps.gather.outputs.pr_count }}" -eq 0 ]; then
            echo "No pending PRs found"
          else
            echo "PRs found: ${{ steps.gather.outputs.pr_count }}"
            
            if [ "${{ steps.merge.outputs.has_changes }}" == "true" ]; then
              echo "Merged and synced in ONE deployment"
              echo "Netlify building (1 build only)"
            else
              echo "No changes to deploy"
            fi
          fi
          
          echo "----------------------------------------"
      
      - name: No PRs to merge
        if: steps.gather.outputs.prs == ''
        run: |
          echo "No pending_publish PRs found to merge"
          echo "Checking if sync is needed anyway..."
      
      - name: Sync service listings even if no PRs (Fallback)
        if: steps.gather.outputs.prs == ''
        run: |
          echo "Running fallback sync to catch any missed services..."
          echo "Current directory: $(pwd)"
          echo "Contents of data/services directory:"
          ls -la data/services/ || echo "data/services/ directory not found"
          
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          console.log('=== FALLBACK SYNC STARTING ===');
          
          // Read existing services.json
          const servicesPath = 'data/services.json';
          let services = [];
          
          if (fs.existsSync(servicesPath)) {
            services = JSON.parse(fs.readFileSync(servicesPath, 'utf8'));
            console.log(`Loaded ${services.length} existing services from services.json`);
          } else {
            console.log('services.json does not exist, will create new one');
          }
          
          // Track the highest existing ID number
          let maxId = 0;
          services.forEach(service => {
            const match = service.id.match(/fb(\d+)/);
            if (match) {
              maxId = Math.max(maxId, parseInt(match[1]));
            }
          });
          
          console.log(`Highest existing ID: fb${maxId}`);
          
          // Get all approved service listing files from data/services
          const servicesDir = 'data/services';
          
          if (!fs.existsSync(servicesDir)) {
            console.log(`Directory ${servicesDir} does not exist`);
            process.exit(0);
          }
          
          const allFiles = fs.readdirSync(servicesDir);
          console.log(`All files in ${servicesDir}:`, allFiles);
          
          const files = allFiles.filter(file => file.endsWith('.json'));
          console.log(`Filtered JSON files:`, files);
          
          if (files.length === 0) {
            console.log('No JSON files found in data/services/');
            process.exit(0);
          }
          
          let changesDetected = false;
          
          files.forEach(file => {
            const filePath = path.join(servicesDir, file);
            console.log(`Processing file: ${filePath}`);
            
            const listing = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            console.log(`Loaded listing: ${listing.name}`);
            
            // Generate unique ID
            let id = file.replace('.json', '').toLowerCase().replace(/[^a-z0-9]/g, '-');
            
            // Check if this listing already exists (by name or ID)
            const existingIndex = services.findIndex(s => 
              s.name === listing.name || s.id === id
            );
            
            // If not using fb{N} format, assign next available fb ID
            if (!id.match(/^fb\d+$/)) {
              if (existingIndex === -1) {
                maxId++;
                id = `fb${maxId}`;
              } else {
                id = services[existingIndex].id;
              }
            }
            
            // Create service object matching services.json format
            const serviceObj = {
              id: id,
              name: listing.name,
              type: listing.type || 'food_bank',
              address: listing.address,
              location: {
                lat: parseFloat(listing.location?.lat || listing.lat || 0),
                lng: parseFloat(listing.location?.lng || listing.lng || 0)
              },
              days: listing.days || [],
              hours: listing.hours || '',
              phone: listing.phone || '',
              description: listing.description || '',
              tags: listing.tags || []
            };
            
            // Add optional fields if they exist
            if (listing.email) serviceObj.email = listing.email;
            if (listing.website) serviceObj.website = listing.website;
            
            if (existingIndex >= 0) {
              // Update existing service
              console.log(`Updating existing service: ${listing.name} (${id})`);
              services[existingIndex] = serviceObj;
              changesDetected = true;
            } else {
              // Add new service
              console.log(`Adding new service: ${listing.name} (${id})`);
              services.push(serviceObj);
              changesDetected = true;
            }
          });
          
          if (!changesDetected) {
            console.log('No changes needed - services.json is already up to date');
            process.exit(0);
          }
          
          // Write updated services.json
          fs.writeFileSync(servicesPath, JSON.stringify(services, null, 2));
          
          console.log(`=== FALLBACK SYNC COMPLETE ===`);
          console.log(`Updated services.json with ${services.length} total services`);
          console.log('Service IDs:', services.map(s => s.id).join(', '));
          EOF
      
      - name: Commit fallback sync changes
        if: steps.gather.outputs.prs == ''
        run: |
          if git diff --quiet data/services.json; then
            echo "No changes to services.json"
          else
            git add data/services.json
            git commit -m "Fallback sync: Update services.json from data/services files"
            git push origin main
            echo "Pushed services.json update from fallback sync"
          fi
